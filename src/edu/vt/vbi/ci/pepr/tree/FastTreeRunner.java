package edu.vt.vbi.ci.pepr.tree;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;

import org.apache.log4j.Logger;

import edu.vt.vbi.ci.pepr.alignment.SequenceAlignment;
import edu.vt.vbi.ci.util.CommandResults;
import edu.vt.vbi.ci.util.ExecUtilities;
import edu.vt.vbi.ci.util.PEPRTracker;
import edu.vt.vbi.ci.util.file.TextFile;

/**
 * This class runs the tree-building program FastTree.
 * 
 * @author enordber
 *
 */
public class FastTreeRunner implements Runnable{

	private SequenceAlignment alignment;
	private String result;
	private String ftPath = null;
	private String runName;
	private String constraints;
	private int bootstrapReps;
	private boolean useRaxmlBranchLengths = false;
	private int threadCount = 1;
	private boolean nucleotide = false;
	private Logger logger = Logger.getLogger(getClass());

	public FastTreeRunner() {
	}

	public void run() {
		String fastTreePath = getFastTreePath();

		//create file for alignment
		File workingDir = new File(System.getProperty("user.dir"));
		try {
			File alignmentFile = File.createTempFile(alignment.getName(), ".faa", workingDir);
			//write alignment to file, as fasta format.
			FileWriter fw = new FileWriter(alignmentFile);
			fw.write(alignment.getAlignmentAsFasta());
			fw.write("\n");
			fw.flush();
			fw.close();
			alignmentFile.deleteOnExit();

			//if constraints have been provided, create constraints file
			String treeConstraints = getConstraints();
			String constraintsFileName = alignmentFile.getName() + ".con";
			boolean useConstraints = false;
			if(treeConstraints != null) {
				useConstraints = true;
				fw = new FileWriter(constraintsFileName);
				fw.write(treeConstraints);
				fw.flush();
				fw.close();
				new File(constraintsFileName).deleteOnExit();
			}
			//create FastTree command
			String alignmentFileName = alignmentFile.getName();
			String fastTreeOptions = " -gamma -nosupport ";
			if(getBootstrapReps() > 0) {
				fastTreeOptions = " -gamma ";
			}

			if(nucleotide) {
				fastTreeOptions = " -gtr -nt -nosupport ";
				if(getBootstrapReps() > 0) {
					fastTreeOptions = "  -gtr -nt  ";
				}
			}

			if(useConstraints) {
				fastTreeOptions = 
						fastTreeOptions + "-constraints " + 
								constraintsFileName + " ";
			}

			String fastTreeCommand = fastTreePath + fastTreeOptions;
			fastTreeCommand = fastTreeCommand + alignmentFileName;

			//execute the command and capture the output. The newick format tree
			//is written to stdout.
			System.out.println("FastTreeRunner.run() build tree with command: " + fastTreeCommand);
			String executableNameOnly = new File(fastTreePath).getName();
			PEPRTracker.setTreeOptions(executableNameOnly + " " + fastTreeOptions);

			CommandResults results = ExecUtilities.exec(fastTreeCommand);
			if(results.getStdout().length > 0) {
				String treeString = results.getStdout()[0];
				if(getBootstrapReps() > 0) {
					//use AdvancedTree to convert decimal support values (0.0-1.0) to integer support values (0-100)
					System.out.println("tree before changing support values:");
					System.out.println(treeString);
					AdvancedTree tree = new AdvancedTree(treeString);
					String[] branchSupports = tree.getBasicTree().getBranchSupportStrings();
					for(int i = 0; i < branchSupports.length; i++) {
						if(branchSupports[i] != null) {
							double support = Double.parseDouble(branchSupports[i]);
							support *= 100;
							branchSupports[i] = ""+ (int)support;
						}
					}
					tree.getBasicTree().setBranchSupportStrings(branchSupports);
					treeString = tree.getTreeString(true, true);
					System.out.println("tree after changing support values:");
					System.out.println(treeString);
				}
				if(getUseRaxmlBranchLengths()) {
					String raxmlTreeString = getRaxmlBranchLengths(treeString, alignment);
					if(raxmlTreeString == null) {
						logger.info("FastTreeRunner had a problem adding RAxML branch lengths to the tree generated by FastTree");
						logger.info("The unaltered FastTree tree is being returned instead.");
					} else {
						treeString = raxmlTreeString;
					}
				}
				setResult(treeString);
			} else {
				logger.error("No FastTree result reported to stdout for alignment file '" + alignmentFileName + "'. Here is stderr:");
				String[] stderr = results.getStderr();
				for(int i = 0; i < stderr.length; i++) {
					logger.error(stderr[i]);
				}
			}
		} catch(IOException ioe) {
			ioe.printStackTrace();
		}
	}

	/**
	 * Takes an input tree string and runs RAxML to get new ML branch lengths.
	 * @param treeString
	 * @return
	 */
	private String getRaxmlBranchLengths(String treeString, SequenceAlignment alignment) {
		String r = null;
		//get raxml path
		String raxmlPath = ExecUtilities.getCommandPath("raxmlHPC");
		if(raxmlPath == null || raxmlPath.trim().startsWith("no ")) {
			raxmlPath = ExecUtilities.getCommandPath("raxml");
		}

		if(getThreadCount() > 1) {
			raxmlPath = ExecUtilities.getCommandPath("raxmlHPC-PTHREADS");
		}

		try {
			File userDir = new File(System.getProperty("user.dir"));
			//write alignment to file
			File alignFile = File.createTempFile("align", ".phy", userDir);
			FileWriter alignWriter = new FileWriter(alignFile);
			alignWriter.write(alignment.getAlignmentAsExtendedPhylipUsingTaxonNames());
			alignWriter.flush();
			alignWriter.close();
			String alignmentFileName = alignFile.getName();

			//write treeString to a file
			File intreeFile = File.createTempFile("intree", ".nwk", userDir);
			FileWriter fw = new FileWriter(intreeFile);
			fw.write(treeString);
			fw.flush();
			fw.close();

			String intreeFileName = intreeFile.getName();

			//create raxml command String
			String raxmlCommand = raxmlPath + 
					" -f e -m PROTGAMMAWAG ";
			if(getThreadCount() > 1) {
				raxmlCommand = raxmlCommand + " -T " + getThreadCount();
			}

			raxmlCommand = raxmlCommand + " -s " + alignmentFileName +
					" -n " + getRunName() + " -t " + intreeFileName;

			//run raxml
			CommandResults raxmlResults = ExecUtilities.exec(raxmlCommand);

			//read raxml result file
			String raxmlTreeFileName = "RAxML_result." + getRunName();
			TextFile raxmlTreeFile = new TextFile(raxmlTreeFileName);

			r = raxmlTreeFile.toString();
			alignFile.delete();
			intreeFile.delete();
			raxmlTreeFile.getFile().delete();
		} catch (IOException e) {
			logger.error(e);
		}

		return r;
	}

	private String getFastTreePath() {
		if(ftPath == null) {
			ftPath = ExecUtilities.getCommandPath("FastTree_WAG");
		}
		return ftPath;
	}

	public void setFastTreePath(String path) {
		ftPath = path;
	}

	public SequenceAlignment getAlignment() {
		return alignment;
	}

	public void setAlignment(SequenceAlignment alignment) {
		this.alignment = alignment;
	}

	public void setConstraints(String constraints) {
		this.constraints = constraints;
	}

	public void setConstraintTree(String treeString) {
		if(treeString != null) {
			String constr = getFastTreeConstraintsForTree(treeString);
			setConstraints(constr);
		}
	}

	private String getConstraints() {
		return constraints;
	}

	public String getResult() {
		return result;
	}

	private void setResult(String result) {
		this.result = result;
	}

	private String getFastTreeConstraintsForTree(String treeString) {
		String r = null;
		AdvancedTree tree = new AdvancedTree(treeString);
		String[] taxa = tree.getLeafLabels();
		Arrays.sort(taxa);

		int nodeCount = tree.getNodeCount();
		int[][] presentAbsent = new int[taxa.length][nodeCount];

		for(int i = 0; i < nodeCount; i++) {
			String[] leavesForNode = tree.getDescendantLeaves(i);
			for(int j = 0; j < leavesForNode.length; j++) {
				int leafIndex = Arrays.binarySearch(taxa, leavesForNode[j]);
				presentAbsent[leafIndex][i] = 1;
			}
		}

		StringBuffer sb = new StringBuffer();
		for(int i = 0; i < taxa.length; i++) {
			sb.append(">");
			sb.append(taxa[i]);
			sb.append("\n");
			for(int j = 0; j < presentAbsent[i].length; j++) {
				sb.append(""+ presentAbsent[i][j]);
			}
			sb.append("\n");
		}

		r = sb.toString();
		return r;
	}

	public boolean getUseRaxmlBranchLengths() {
		return useRaxmlBranchLengths;
	}

	public void setUseRaxmlBranchLengths(boolean useRaxmlBranchLengths) {
		this.useRaxmlBranchLengths = useRaxmlBranchLengths;
	}

	public int getThreadCount() {
		return threadCount;
	}

	public void setThreadCount(int threadCount) {
		this.threadCount = threadCount;
	}

	private String getRunName() {
		return runName;
	}

	public void setRunName(String runName) {
		this.runName = runName;
	}

	public void setNucleoide(boolean nuc) {
		nucleotide = nuc;
	}

	private int getBootstrapReps() {
		return bootstrapReps;
	}

	public void setBootstrapReps(int reps) {
		bootstrapReps = reps;
	}


}
